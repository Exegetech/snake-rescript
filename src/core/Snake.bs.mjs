// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Food from "./Food.bs.mjs";
import * as Settings from "./Settings.bs.mjs";
import * as Core__Array from "@rescript/core/src/Core__Array.bs.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.mjs";

function make() {
  return {
          x: 160,
          y: 160,
          dx: Settings.grid,
          dy: 0,
          cells: [],
          maxCells: 4
        };
}

function getDx(snake) {
  return snake.dx;
}

function getDy(snake) {
  return snake.dy;
}

function setSpeedLeft(snake) {
  return {
          x: snake.x,
          y: snake.y,
          dx: -Settings.grid | 0,
          dy: 0,
          cells: snake.cells,
          maxCells: snake.maxCells
        };
}

function setSpeedUp(snake) {
  return {
          x: snake.x,
          y: snake.y,
          dx: 0,
          dy: -Settings.grid | 0,
          cells: snake.cells,
          maxCells: snake.maxCells
        };
}

function setSpeedRight(snake) {
  return {
          x: snake.x,
          y: snake.y,
          dx: Settings.grid,
          dy: 0,
          cells: snake.cells,
          maxCells: snake.maxCells
        };
}

function setSpeedDown(snake) {
  return {
          x: snake.x,
          y: snake.y,
          dx: 0,
          dy: Settings.grid,
          cells: snake.cells,
          maxCells: snake.maxCells
        };
}

function increaseMaxCells(snake) {
  return {
          x: snake.x,
          y: snake.y,
          dx: snake.dx,
          dy: snake.dy,
          cells: snake.cells,
          maxCells: snake.maxCells + 1 | 0
        };
}

function iterateCells(snake, callback) {
  snake.cells.forEach(function (cell) {
        callback(cell.x, cell.y);
      });
}

function wrapX(snakeX, width) {
  if (snakeX < 0) {
    return width - Settings.grid | 0;
  } else if (snakeX >= width) {
    return 0;
  } else {
    return snakeX;
  }
}

function wrapY(snakeY, height) {
  if (snakeY < 0) {
    return height - Settings.grid | 0;
  } else if (snakeY >= height) {
    return 0;
  } else {
    return snakeY;
  }
}

function extendCells(x, y, cells, maxCells) {
  var cells$1 = cells.slice();
  var newCell = {
    x: x,
    y: y
  };
  cells$1.unshift(newCell);
  if (cells$1.length > maxCells) {
    cells$1.pop();
  }
  return cells$1;
}

function move(snake, boardWidth, boardHeight) {
  var newX = wrapX(snake.x + snake.dx | 0, boardWidth);
  var newY = wrapY(snake.y + snake.dy | 0, boardHeight);
  var newCells = extendCells(newX, newY, snake.cells, snake.maxCells);
  return {
          x: newX,
          y: newY,
          dx: snake.dx,
          dy: snake.dy,
          cells: newCells,
          maxCells: snake.maxCells
        };
}

function eatFood(snake, food) {
  return Core__Array.findIndexOpt(snake.cells, (function (cell) {
                if (cell.x === Food.getX(food)) {
                  return cell.y === Food.getY(food);
                } else {
                  return false;
                }
              })) !== undefined;
}

function eatSelf(snake) {
  return Core__Array.reduceWithIndex(snake.cells, false, (function (acc, cell, index) {
                var found = false;
                var i = index + 1 | 0;
                while(found === false && i < (snake.cells.length - 1 | 0)) {
                  var snakeCell = Core__Option.getExn(snake.cells[i]);
                  found = cell.x === snakeCell.x && cell.y === snakeCell.y ? true : false;
                  i = i + 1 | 0;
                };
                if (acc) {
                  return true;
                } else {
                  return found;
                }
              }));
}

export {
  make ,
  getDx ,
  getDy ,
  setSpeedLeft ,
  setSpeedUp ,
  setSpeedRight ,
  setSpeedDown ,
  increaseMaxCells ,
  iterateCells ,
  move ,
  eatFood ,
  eatSelf ,
}
/* No side effect */
